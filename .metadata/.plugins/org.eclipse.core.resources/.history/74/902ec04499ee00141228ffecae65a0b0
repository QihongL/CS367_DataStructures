//////////////////////////////////////////////////////////////////////////////
//                   ALL STUDENTS COMPLETE THESE SECTIONS
// Main Class File:  SocialNetworkingApp.java
// File:             SocialGraph.java
// Semester:         CS367 Spring 2015
// Author:           Qihong Lu
// Email:            qlu36@wisc.edu
// CS Login:         qihong
// Lecturer's Name:  Jim Skrentny
//
//////////////////////////// 80 columns wide /////////////////////////////////
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

/**
 * The class that defines the SocialGraph. It has some functions that specific 
 * to  which extends the functionality
 * of undirectedGraph.
 * @author Qihong
 *
 */
public class SocialGraph extends UndirectedGraph<String> {

    /**
     * Creates an empty social graph.
     * 
     * DO NOT MODIFY THIS CONSTRUCTOR.
     */
    public SocialGraph() {
        super();
    }

    /**
     * Creates a graph from a preconstructed hashmap.
     * This method will be used to test your submissions. You will not find this
     * in a regular ADT.
     * 
     * DO NOT MODIFY THIS CONSTRUCTOR.
     * DO NOT CALL THIS CONSTRUCTOR ANYWHERE IN YOUR SUBMISSION.
     * 
     * @param hashmap adjacency lists representation of a graph that has no
     * loops and is not a multigraph.
     */
    public SocialGraph(HashMap<String, ArrayList<String>> hashmap) {
        super(hashmap);
    }
    
    /**
     * 
     * @param person
     * @return
     */
    public Set<String> friendsOfFriends(String person) {
        //TODO
    	// create a empty set to store friends of friends
    	Set<String> fofs = new HashSet();
    	Iterator<String> itr = hashmap.get(person).iterator();
    	// loop over all 1-dgree friends
    	while(itr.hasNext()){
    		String friend = itr.next();
    		Iterator<String> fofItr = hashmap.get(friend).iterator();
    		// get friends of friends
    		while(fofItr.hasNext()){
    			String fof = fofItr.next();
        		fofs.add(fof);
    		}
    	}
    	// exclude the current person 
    	fofs.remove(person);
    	// remove 1-dgree friend
    	itr = hashmap.get(person).iterator();
    	while(itr.hasNext()){
    		String friend = itr.next();
    		fofs.remove(friend);
    	}    	
        return fofs;
    }

    /**
     * 
     * @param pFrom
     * @param pTo
     * @return
     */
    public List<String> getPathBetween(String pFrom, String pTo) {
        //TODO
    	ArrayList<String> frontier = new ArrayList<String>();
    	// Create an new empty set
    	HashSet <String> explored = new HashSet<String>();
    	// Map every vertex in frontier and explored to its depth
    	// Create new empty hashmap
    	HashMap <String, ArrayList<String>> depths = new HashMap<String,ArrayList<String>>();
    	depths.put(pFrom,null);

    	while (!frontier.isEmpty()){
    	  String vertex = frontier.remove(0);
//    	  if (depths.get(vertex) > pTo) 
//    		  break;
//    	  explored.add(vertex);
    	  
    	  // for each neighbor of vertex
    	  Iterator<String> itr = hashmap.get(vertex).iterator();
    	  while(itr.hasNext()){
    		  String temp = itr.next();
    		  if(!frontier.contains(temp) && !explored.contains(temp)){
    			  
//    	      depths.put(neighbor, depths[vertex] + 1)
//    	      frontier.enqueue(neighbor)
    		  }
    			  
    	  }

    	}


//    	return (all vertices in depths with depth N)
        return null;
    }

    /**
     * Returns a pretty-print of this graph in adjacency matrix form.
     * People are sorted in alphabetical order, "X" denotes friendship.
     * 
     * This method has been written for your convenience (e.g., for debugging).
     * You are free to modify it or remove the method entirely.
     * THIS METHOD WILL NOT BE PART OF GRADING.
     *
     * NOTE: this method assumes that the internal hashmap is valid (e.g., no
     * loop, graph is not a multigraph). USE IT AT YOUR OWN RISK.
     *
     * @return pretty-print of this graph
     */
    public String pprint() {
        // Get alphabetical list of people, for prettiness
        List<String> people = new ArrayList<String>(this.hashmap.keySet());
        Collections.sort(people);

        // String writer is easier than appending tons of strings
        StringWriter writer = new StringWriter();

        // Print labels for matrix columns
        writer.append("   ");
        for (String person: people)
            writer.append(" " + person);
        writer.append("\n");

        // Print one line of social connections for each person
        for (String source: people) {
            writer.append(source);
            for (String target: people) {
                if (this.getNeighbors(source).contains(target))
                    writer.append("  X ");
                else
                    writer.append("    ");
            }
            writer.append("\n");

        }

        // Remove last newline so that multiple printlns don't have empty
        // lines in between
        String string = writer.toString();
        return string.substring(0, string.length() - 1);
    }

}